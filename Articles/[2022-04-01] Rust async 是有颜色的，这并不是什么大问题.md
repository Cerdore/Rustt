> 原文链接: https://morestina.net/blog/1686/rust-async-is-colored
>
> **翻译：[BK0717](https://github.com/hyuuko)**
>
> 选题：[BK0717](https://github.com/hyuuko)
>
> 本文由 [Rustt](https://Rustt.org) 翻译，[StudyRust](https://studyrust.org) 荣誉推出

# Rust async 是有颜色的，这并不是什么大问题

在过去的几年里，对异步友好的语言和 API 备受关注。语言设计领域的一个争议点是“有色函数”，或者异步与非异步函数的区分。这个术语是由 2015 年那篇题为“[你的函数是什么颜色的？](https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/)”的文章引入的，该文章用颜色来类比 JavaScript 和其他具有明确的异步函数的语言中同步和异步函数之间经常出现的痛苦的不匹配。自 2015 年以来，有更多的语言加入了 aysnc 的行列，所以现在有更多的程序员开始熟悉这个类比。随着一些语言设法在不使用有色函数的情况下提供异步 IO，如 Go、[Zig](https://kristoff.it/blog/zig-colorblind-async-await/)，以及未来可能的 [Java](https://wiki.openjdk.java.net/display/loom/Main)，围绕函数颜色的讨论又多了起来。有些人甚至试图争辩说，有色函数的坏名声并不适用于 Rust 的异步，因为它本来就不是有色的。几天前的一篇文章的标题是[“Rust 的 async 并不是 f#@king colored!”](https://www.hobofan.com/blog/2021-03-10-rust-async-colored/)，类似的论点也出现在 reddit 上。我不是在针对某个特定的帖子，但我想对这种争论做一个普遍的回应。

在这篇文章中，我将说明 Rust 的异步函数是有色的，无论是从最初的定义还是从实践来看。这并不是对 Rust 异步的批评——我不认为函数的颜色是一个不可克服的问题，而是反映了异步和同步模型的根本区别。掩盖这种差异的语言是通过引入在 Rust 或 C++ 这样的系统语言中可能无法接受的妥协来实现的——例如，完全禁止使用系统线程，或使外部调用复杂化，或者使用阻塞的系统调用。有色函数也存在于 C#、Python、Kotlin 和 C++，所以它们不是 JavaScript 和 Rust 的怪癖。而且 Rust async 的一些额外功能确实使异步代码与传统的阻塞代码更容易连接，这在 JavaScript 中是不可能的。

## 有色函数

“你的函数是什么颜色的？”这篇文章一开始就描述了一种想象中的语言，并定义了两种类型的函数：红色和蓝色。这门语言对这两种函数的交互方式施加了一系列看似随意的规则：

1. 每个函数都有一个颜色。
2. 你调用一个函数的方式取决于它的颜色。
3. 你只能从另一个红色函数中调用一个红色函数。
4. 红色函数的调用是比较痛苦的。
5. 一些核心库函数是红色的。

在不了解细节的情况下，理智的人都会觉得以上规则所描述的语言并不是特别好的设计。当然，2021 年这篇文章的读者不难认识到这与 async 的类比：红色函数是 async 函数，而蓝色函数只是普通函数。例如，#2 和#4 指的是，调用一个异步函数需要明确的回调链或 `await`，而同步函数可以直接调用。#3 指的是，`await` 和回调只在异步函数内部工作，而 JavaScript 没有提供一种方式来阻塞当前的非异步函数，直到一个 promise 被 resolve。这篇文章将 async 函数描绘成了一个会对语言产生深刻的负面影响的[抽象泄漏](https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/)。

async 的规则使 async 代码具有传染性，因为只要在一个地方使用一个 async 函数，就要求栈上所有的调用者都变成 async。这就把生态分裂成了异步和非异步库，几乎没有相互使用的可能。这篇文章将 async 函数描述为对传统的 JavaScript 回调进行操作的函数，并进一步认为当时很新颖的 async/await 并不能帮助解决这个问题。尽管 await 对从 async 调用 async 带来了很大的人体工程学上的改进 (#4)，但它对缓解分裂问题毫无帮助——你仍然不能从非 async 代码中调用 async 代码，因为 await 需要 async。

## Rust async 中的函数颜色

这一切是如何适用于 Rust 的呢？许多人认为，它只适用于一部分，或者根本不适用。有人提出了几个反对意见：

1. Rust 的 async 函数本质上还是普通的函数，只是碰巧返回了实现了 `Future` 特征的值。`async fn` 只是定义这种函数的语法糖，你也可以自己写个返回 `Future` 的普通 `fn`。这种说法认为，async 函数返回的是 `Future<Output = T>` 而非 `T`，因此在任何方面都并不“特殊”，就像是返回 `Result<T>` 而非 `T` 一样——所以规则 #1（“每个函数都有一个颜色”）并不适用。
2. 与 JavaScript 不同，Rust 的异步执行器提供了一个 [`block_on()`](https://docs.rs/async-std/1.9.0/async_std/task/fn.block_on.html) 原语，可以从非异步上下文中调用一个异步函数，并在结果可用之前进行阻塞——所以规则 #3（“你只能从另一个红色函数中调用一个红色函数”）并不适用。
3. 同样与 JavaScript 不同的是，Rust async 提供了 [`spawn_blocking()`](https://docs.rs/async-std/1.9.0/async_std/task/fn.spawn_blocking.html)，它从一个异步上下文中调用了一个阻塞的同步函数，暂时中止了当前的异步函数，而不阻塞异步环境的其他部分。这条规则与原文中的规则并不对应，因为 JavaScript 不支持阻塞的同步函数。
4. 规则 #5（“一些核心库函数是红色的”）并不适用，因为 Rust 的标准库只支持同步。

如果这些论点是正确的，那么唯一剩下的颜色规则就是规则 #4，“红色的函数调用起来更痛苦”，而这部分几乎完全被 `await` 缓解了。无论在 JavaScript 还是 Rust 中，原本 JavaScript 的问题，即异步函数“由于回调的缘故而不能在表达式中进行组合”或“有不同的错误处理”，在 `await` 下根本不存在。从表面上看，整个函数颜色的问题似乎是编造的，或者至少是疯狂地夸大了 Rust async 并没有继承的一些奇特的 JavaScript 问题。不幸的是，事实并非如此。

首先，同步和异步生态之间的分裂对于任何一个关注该生态的人来说都是显而易见的。`async_std` crate 的明确的目的是提供“Rust 标准库的异步版本”，这表明了常规的标准库在异步情况下是不可用的。如果 Rust 中不存在函数颜色，stdlib 就会被用于同步和异步代码中，就像 Go 中的情况一样，“同步”和“异步”之间的区别从一开始就不存在。

那么反对意见是什么呢？让我们逐一分析，看看它们在仔细的分析下是如何成立的。

## Rust 的异步函数不就是带有古怪的返回类型的普通函数吗？

虽然在技术上是这样，但在 JavaScript 和几乎所有带颜色的 async 语言（Kotlin 除外）中也是如此，方式完全相同。JavaScript 的 async 函数是创建和返回 Promise 的函数的语法糖。Python 的异步函数是普通的可调用的函数，可以立即返回一个 coroutine 对象。这并没有改变这样一个事实：在所有这些语言中，调用者必须以不同于处理从函数返回的正常值的方式来处理返回的 `Promise`（Python 中的 coroutine 对象，Rust 中的 `Future`）。例如，你不能向 `Iterator::filter()` 传递一个异步函数，因为 `Iterator::filter()` 期待一个返回实际的 `bool` 的函数，而不是一个不透明的只是可能在未来的某个时刻产生一个 bool 的值。无论你在你的异步函数的主体中加入什么，它都不会返回 bool，而且提取 bool 需要执行者的魔法，这就产生了其他问题，我们会在下面看到。不管在技术上是否可以从同步上下文中调用一个异步函数，能否直接获取到其结果是函数颜色区分的核心所在。

好吧，但 `Result` 不是同样的情况吗？需要 `u32` 的函数并不特别乐于接收一个` Result<u32, SomeError>`。一个接受 `u32` 的通用函数，比如 `Iterator::min()`，不知道该如何处理 `Result<u32, SomeError>`。然而，人们并没有到处宣称 `Result` 在某种程度上为他们的函数“着色”。我承认这种说法是有道理的——`Result` 确实引入了一种语义上的转变，而这种转变并不总是容易弥合的，包括在我们上面使用的例子 `Iterator::filter()`。甚至还有人[提议](https://blog.yoshuawuyts.com/fallible-iterator-adapters/)增加 21 个新的迭代器方法，如 `try_filter()`、`try_min_by_key()`、`try_is_partitioned()` 等等，以支持在你的 filter 函数（和 key 函数等）中做 IO。要完全做到这一点，可能需要 Haskell 风格的 monads，或者至少是某种形式的高阶类型。所有这些都表明，在完全泛型的代码中支持 `Result` 和 non-`Result` 类型远不是一件小事。但这足以证明 `Result` 和 `Future` 在影响必须处理它们的函数方面是等同的吗？我认为不是这样的，原因如下。

如果 `Result` 的接收者不关心错误的情况，它就可以直接通过 unwrap 将 `Result` 分解为实际值。如果它不想在出错时 panic，它可以选择将错误转换为一个默认值，或者跳过对该值的处理。虽然它可以使用 `?` 操作符将错误传播给它的调用者，但它没有义务这样做。`Future` 的接收者没有这样的选择——它可以对 future 进行 `.await`，在这种情况下，它自己必须成为异步的，或者它必须要求一个执行器来处理 future，在这种情况下，它必须能够访问一个执行器，并被许可进行阻塞。它做不到的是在不与异步环境交互的情况下获得底层的值。

结论：规则 #1 几乎适用于 Rust——异步函数很特别，因为它们返回的值需要异步上下文来获取实际的值。

## `block_on()` 不是提供了一种方便的方式来在非异步上下文中调用异步函数吗？

是的，前提是你真的被允许使用它。库应该与环境提供的执行器一起工作，而不是有一个可以直接被调用来处理异步代码的执行器躺在那里。例如，标准库当然不允许承担任何特定的执行器，而且目前也没有对第三方执行器进行抽象的特征。

但是，即使你可以访问执行器，`block_on()` 还有一个更根本的问题。考虑一个同步函数 `fn foo()`，在其运行过程中，需要从一个异步函数 `async fn bar()` 中获取值。为了做到这一点，`foo()` 做了一些事情，比如 `let bar_result = block_on(bar())`。但这意味着 `foo()` 不再只是一个非异步函数，它现在是一个阻塞的非异步函数。这意味着什么呢？这意味着 `foo()` 可以在等待 `bar()` 完成的过程中阻塞任意长的时间。异步函数不允许调用像 `foo()` 这样的函数，原因与不允许调用 `thread::sleep()` 或 `TcpStream::connect()` 一样——从异步代码中调用一个阻塞函数会使整个执行线程停止，直到阻塞函数返回。如果这种情况发生在多个线程中，或发生在单线程的执行器中，那么就会冻结整个异步系统。这一点在那篇函数颜色文章中没有描述。但其中的含义很清楚：使用 `block_on()` 的函数不再是蓝色，但也不是红色——它是一种新的颜色，我们称之为紫色。

情况越来越糟了。考虑另一个异步函数 `xyzzy()`，它需要调用 `foo()`。如果 `foo()` 是一个蓝色/非异步函数，`xyzzy()` 会直接调用它并完成它，就像它不假思索地调用 `HashMap::get()` 或 `Option::take()` 那样。但 `foo()` 是一个紫色的函数，它在 `block_on(bar())` 上阻塞，`xyzzy()` 不允许调用它。`xyzzy()` 和 `bar()` 都是异步的，如果 `xyzzy()` 能直接 await `bar()`，一切都会好起来。`xyzzy()` 通过非异步的 `foo()` 调用 `bar()` 就是问题所在——`foo()` 对 `block_on()` 的使用破坏了 `bar()` 向 `xyzzy()` 所传达的它需要暂停直至进一步通知所需的暂停链。将暂停从最底层的 awaitee（被 await 的函数，比如 future）一直传播到执行者的能力是 async 必须具有传染性的实际原因。通过从 `foo()` 的函数签名中消除 async，也就消除了 `bar()` 是 async 的大部分优势，以及从 async 代码中调用 `foo()` 的可能性。

结论：规则 #3 适用，因为 `block_on()` 把一个蓝色的函数变成了一个既不是红色也不能从红色调用的东西。

## `spawn_blocking()` 不是解决了在异步背景下等待阻塞函数的问题吗？

`spawn_blocking()` 是同步和异步代码之间的一个巧妙的桥梁：它接收一个可能需要很长时间才能执行的同步函数，而不是调用它，而是将它提交给线程池来执行。它返回一个 `Future`，所以你可以像等待一个真正的异步函数一样等待 `spawn_blocking(|| some_blocking_call())`，而不会出现 `block_on()` 的问题。这是因为 `spawn_blocking()` 返回的 `Future` 是 pending 的，直到线程池报告说它已经完成了提交的同步函数的执行。在我们扩展的颜色比喻中，`spawn_blocking()` 是一个适配器，它将紫色函数转换为红色函数。它的主要用途是执行起来可能需要很长时间的 CPU 密集型的函数，以及没有好的异步替代方法的阻塞函数。后者的例子是与文件系统一起工作的仍然没有一个好的异步替代方案的函数，或者 FFI 背后的传统阻塞代码（老旧的数据库驱动程序之类的）。

当代码试图避免多个函数的颜色并使用 `block_on()` 或 `spawn_blocking()` 来隐藏实现的“颜色”时，问题就出现了。例如，一个库可能在内部使用异步代码实现，但它使用 `block_on()` 并只暴露了一个同步 API。有人可能会在一个异步环境中使用该库，并将同步调用包裹在 `spawn_blocking()` 中。如果这样做了，会有什么后果呢？回顾一下，异步的重要优势是能够在不增加操作系统线程数量的情况下增加并发任务（futures）的数量。只要任务大多是 IO 密集型的，你就可以在一个线程上执行数以百万计的任务（其中大部分在任何特定时间都是暂停的）。但是，如果像上面的 `xyzzy()` 这样的异步函数使用 `spawn_blocking()` 来等待 `foo()` 这样的紫色函数，而 `foo()` 本身使用 `block_on()` 来等待 `bar()` 这样的异步函数，那么我们就有一个问题：现在，可以并发运行并取得进展的 `xyzzy()` 实例的数量受到 `spawn_blocking()` 使用的线程池中线程数量的限制。如果你需要生成大量并发等待 `xyzzy()` 的任务，那么在它们的 `foo()` 函数开始执行之前，它们中的大多数都需要等待线程池中的一个空位。而这一切都是因为 `foo()` 在 `bar()` 上阻塞，这很不应该，因为 `bar()` 作为一个异步函数，其伸缩性本应独立于可执行的线程数。

上述情况不仅仅是性能下降的问题。在最坏的情况下，`spawn_blocking(|| block_on(...))` 会出现死锁。考虑一下如果一个在 `spawn_blocking(|| block_on(...))` 后面的异步函数需要另一个以同样方式启动的异步函数的数据才能继续进行，会发生什么。另一个异步函数有可能无法取得进展，因为它正在等待线程池中的一个空位，甚至无法开始执行。而这个空位不会释放出来，因为它被第一个异步函数占用了，这个函数也是在 `spawn_blocking()` 调用中运行的。这个空位永远不会改变所有者，死锁就出现了。这种情况不会发生在作为异步任务直接执行的异步函数上，因为这些函数不需要固定大小的池中的空位。它们全都可以处于暂停状态，等待其中任何一个发生的事情，并在任何时候恢复执行。在一个异步系统中，由执行器部署的操作系统线程的数量并不限制可以并发工作的异步函数的数量。（有一些执行者只使用一个线程来驱动所有的 future）。

结论：`spawn_blocking()` 与 CPU 密集型的或真正的阻塞代码一起使用很好，但与 `block_on()` 一起使用不是一个好主意，因为这样就失去了异步的优势，有可能出现死锁。

## 但是 Rust 的标准库是纯同步的。

这在技术上是正确的，但 Rust 的标准库是有意的最小化。与 Rust 相关的重要功能部分被委托给了外部 crate，并取得了巨大的成功。现在许多这些外部板块都需要 async，甚至是像 tokio 这样的特定执行器。因此，虽然标准库是无异步的，但在 Rust 中编程时，你不能忽视异步。

结论：技术上是正确的，但在一个具有最小化标准库的语言中这并不实用。

## 与一个双色的世界相处

再次强调，以上并不是对 Rust async 的批评，而只是对它没有颜色的说法的批评。一旦我们接受它是有色的，就会发现，与 JavaScript 不同，Rust 实际上提供了我们需要的工具来处理这种不匹配。我们可以：

1. 接受同步和异步是两个不同的世界，不要试图隐藏它。特别是，不要写那些用 `block_on()` 来隐藏异步的“同步”接口，反之则用 `spawn_blocking()`。如果你一定要把异步接口隐藏在同步接口后面，那就在入口处立即这样做，记录下你这样做的原因，并为底层的原生调用提供一个公共接口。
2. 在尊重上述内容的前提下，在两个世界的边界上的应用层级的代码中使用 `block_on()` 和 `spawn_blocking()`。
3. 在更复杂的情况下，在两个世界之间建立清晰的、有记录的边界，并使用 channel 在它们之间进行通信。这种技术已经被用于多线程和异步代码，所以对于未来的维护者来说应该不会感到惊讶。理想情况下，你应该使用同时提供[同步和异步接口的 channel](https://stackoverflow.com/questions/63363513/sync-async-interoperable-channels)，但如果这些接口不可用，就在同步代码中使用带有 `block_on()` 的异步 channel。
