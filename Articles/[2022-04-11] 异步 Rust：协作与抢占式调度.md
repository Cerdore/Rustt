> 原文链接: https://kerkour.com/cooperative-vs-preemptive-scheduling
>
> **翻译：[trdthg](https://github.com/trdthg)**
>
> 选题：[Akagi201](https://github.com/Akagi201)
>
> 本文由 [Rustt](https://Rustt.org) 翻译，[StudyRust](https://studyrust.org) 荣誉推出

# 异步 Rust：协作与抢占式调度

> 这篇文章包含一些书 ( [Black Hat Rust](https://kerkour.com/black-hat-rust) ) 中的摘录

多线程设计用来并行的执行计算密集型任务。但是现在，越来越多的程序 (比如网络扫描器) 执行的是 I/O 密集型任务。

因此，多线程有两个问题：

- 占用内存高 (相比于别的解决方案)
- 线程的启动和线程间切换的开销比较大。当有大量线程 (大概 10 万) 同时运行时，这种开销是可以感知的

在实践中就意味着，如果使用线程，我们的程序就会花费大量时间去等待请求完成，占用很多不必要的资源。

`async-await` 是一种较好的解决方案。

## 多线程存在的问题

> 这部分可以参考
> [异步 vs 多线程](https://course.rs/async-rust/async/getting-started.html#rust-async-vs-%E5%A4%9A%E7%BA%BF%E7%A8%8B)

从一个程序员的角度来看，`async/await` 和多线程一样，为我们的程序提供了 并发性，更好的硬件使用率以及更快的速度。但是同时，他还为 I/O
密集型任务提供了明显更好的性能和更低的资源占用率。

什么是 I/O 密集型任务？这种任务的运行速度很大程度上受制于网络或者磁盘操作，而不是 CPU 的计算能力。

多线程的诞生时间很早，那时候的很多计算任务还不依赖于网络，它并不适合用于高并发的 I/O 任务

| 操作    | 异步               | 多线程              |
| ----- | ---------------- | ---------------- |
| 创建    | 0.3 microseconds | 17 microseconds  |
| 切换上下文 | 0.2 microseconds | 1.7 microseconds |

从上面的图中我们可以看到，异步进行上下文切换的速度是线程的 8.5 倍。内存消耗也只有线程的 1/20。

在编程语言的世界里，处理 I/O 任务有两种方式：**抢占式调度 (preemptive scheduling)** 和 **协作式调度
(cooperative scheduling)**。

## 抢占式调度

抢占式调度是指任务的调度不受开发人员的控制，完全由一个运行时去管理。不管程序在运行同步任务还是异步任务，在代码层面他们是一样的。[Go](https://golang.org/)
语言就依赖于抢占式调度。

抢占式调度有很多优点

- 更易于学习：对于开发者来说，异步和同步代码是一样的。
- 几乎不可能被滥用：因为运行时会帮我们打理好一切。

下面是在 Go 里发起一个 HTTP 请求的例子：

```go
resp, err := http.Get("http://kerkour.com")
```

仅仅查看这段代码，我们不能分辨 `http.Get` 方法到底是 I/O 密集型还是计算密集型。

当然抢占式调度也有一些缺点：

- 速度：完全取决于运行时的管理能力
- 难以调试：如果运行时出现 bug，可能很难发现原因，因为运行时对于开发者就像黑魔法。

## 协作式调度

在协作式调度中，开发者需要负责告诉运行时，我们的异步任务在什么时候可能需要等待 I/O 完成。这里的等待就是 `await` 关键字出现的原因。`await`
关键字是给运行时或者编译器的一种提示，告诉它这个任务可能要花费一段时间等待任务完成，现在计算资源能够同时分配给其他任务运行。

它的优点是 **速度极快**。开发人员能够和运行时协同工作，以充分利用可支配的计算能力。

主要的缺点是很容易被滥用：如果开发者忘记添加 `await` 关键字 (幸好 Rust
编译器会给出警告)，或者是[事件循环](https://kerkour.com/rust-async-await-what-is-a-runtime)阻塞了很长时间
(超过几微秒)，就会对系统的性能造成非常严重的影响。

使用协作式调度时，异步程序必须非常谨慎的对待计算密集型操作

下面是一个在 Rust 里发送 HTTP 请求的例子：

```rs
let res = reqwest::get("https://www.rust-lang.org").await?;
```

`.await` 关键字告诉我们 `reqwest::get` 函数需要等待一些时间才能完成。

## 运行时

请参考下一篇文章
