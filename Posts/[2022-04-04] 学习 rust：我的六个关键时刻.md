# [2022-04-04] 学习 rust：我的六个关键时刻

如果你曾经尝试学习 Rust 或者至少研究过它，你可能在某个地方了解到它是一个有陡峭学习曲线的编程语言。对于我这样一个有用过几种编程语言（主要是 C）的有编写代码背景的人来说，这句话在一定程度上是真的。实际上，我也同样认为在计算机系统的一些底层领域的知识帮助了我更快地理解 Rust。尽管如此，这仍然是一段令人惊奇的旅程。我发现自己经常在想 Rust 多么有意义，特别是从系统的角度思考语言如何处理问题的。如果想了解更多，你可以阅读我的上一篇博文 *[《学习 Rust 时我喜欢的五件事》](https://apollolabsblog.hashnode.dev/5-things-i-loved-about-learning-rust)*。

值得指出的是，我个人学习 Rust 是为了用它来进行嵌入式开发。为了我的目的，可能学习到*[《Rust 程序设计》](https://doc.rust-lang.org/book/)*的第六章或者第七章就足够了，然而，对我来说，我真的想更进一步了解 Rust，因为我发现自己是多么地被这门语言所吸引，并有着强烈求知欲望去更深入的理解它。

话虽如此，下面我列出来六件贯穿我在 Rust 学习旅途中的，让我感到学习理解 Rust 的关键时刻的事。需要留心的是这些或许并不是理解 Rust 最棘手的概念，此外，其中大部分可能在我使用的资源中提到过。然而，我觉得这些概念对我理解 Rust 有着非常关键的作用，因为它们经常被巧妙地解释，虽然用得很广泛。

**1) 一切都是为了 References!**

几乎所有学习 Rust 的人（或许还有一些开发者）会告诉你关于与借用检查（borrow checker）时的挣扎。在 Rust 中，所有权（Ownership）和借用（borrowing）真的是非常强大的概念，然而，这些概念需要认真关注和努力，才能正确理解。另外我想补充的是，当牢牢地把握这些概念时，你甚至可能会觉得自己已经成为某种无敌的程序员的存在了。多亏了我在 YouTube 上找到的 *[Doug Milford](https://www.youtube.com/channel/UCmBgC0JN41HjyjAXfkdkp-Q)* 的一系列关于 Rust 的视频，我得到了急需的解释。在Doug 的视频 *[Rust 所有权和借用](https://www.youtube.com/watch?v=lQ7XF-6HYGc&list=PLLqEtX6ql2EyPAZ1M2_C0GgVd4A-_L4_5&index=13)* 中，他演示了相当多的借用的例子。我最初的理解是所有的值都可以由一个变量拥有，并且不能被传递，除非它们被克隆或者借用。如果值没有被借用，则会在其作用域结束时被释放掉。事实证明，这并不总是正确的，异常是在栈中创建的固定大小的变量（即非局部变量）。在 Rust 术语中，固定大小的变量（在栈中创建的变量）实现了一个 `copy` Trait，这允许它们哪怕没有被借出，也不会在其作用域结束时被释放。这很合理，因为当传递一个无指针的位于栈上的局部变量时，该变量通过值（复制 / 克隆）传递给被调用的函数，通过活动记录（Activation Record，常称栈帧），当函数结束的时候就被删除了（所以为什么要担心借用呢？）为了演示一个简单的例子，让我们假设我们有以下的东西：

```
fn main() {
    let some_string = String::from("hello");
    let other_string = some_string;
    println!("{}", some_string);
}

```

这段代码会得到编译错误，因为这里只能有一个 `String` 的所有者。如果 Rust 允许这段代码运行，这意味着我们将拥有两个变量  `some_string` 和 `other_string` 同时指向了同样的 `String` , 这绝对不行。你可能想问为什么？因为如果这样的写法时被允许的，这意味着两个不同的变量可以改变同一个位置，这在并行编程中，是一个潜在的灾难。因此，基于这一点，现在你可能认为下面的代码也会产生一个编译错误:

```rust
fn main() {
    let a = 10;
    let b = a;
    println!("{}", a);
}
```

有趣的是，它并没有错误。为什么？这是因为，由于这些变量没有涉及指针，而且两个变量都在栈上，因此我们只是创建了  `a` 变量的值的一个副本  `b`。我们没有多个指针指向一个可以改变一个值的地址，因此没有潜在的危机。这就说得通了！

在某种程度上，后者是一个非 Rust 程序员会使用的代码。当我回去检查是否遗漏了什么东西时，发现这个异常在《Rust 程序设计》第四章的某个地方被提到过。我觉得在书中强调得不够。问题是，在这一章的开头，所有权规则从一开始就被提到了，不知怎么的，我的思维就被这些规则应用到以后的所有事情上而耗尽了。然而，正如前面解释的那样，或多或少，尽管所有权仍然适用，但当涉及到栈中的固定大小变量时，仍然存在一个“问题”。

我想这可能是 Rust 学习曲线很陡峭的因素之一。大多数程序员习惯的标准的部分在 Rust 中可能是错误的。更好的方法可能是从展示编程中相同的东西开始，然后引入 Rust 的行为。

**2) `::` 操作符 vs. `.` 操作符**

在浏览概念和编写新代码的时候，我经常遇到 `::` 和 `.` 操作符，感觉它们可以互换替换的。我没有弄明白使用他们的正确模式。我认为 `.` 操作符更容易掌握，因为它的使用方式与我习惯的传统编程语言相似，其本质上是调用方法和访问结构体成员。 `::` 操作符则较难以理解。根据我不那么清晰的记忆，我记得 C++ 在名称空间作用域问题的处理上，使用类似的操作符（并不是说我一开始就喜欢 C++ 命名空间）。我遇到的最主要的问题是我通常会用 `.` 操作符获取一个对象身上的属性时，Rust 却使用 `::` 。这说明有两种类型的方法；属于类型的实例的方法和属于类型本身的方法。举例来说，如果类型被实例化，那么我们将对所有实例方法使用 `.` 操作符。但是，如果类型没有实例化，那么我们将使用: : 操作符调用一些方法（静态方法）。通常可以在字符串中看到这样的用法示例：

```rust
let h = String::from("Hello world!");
```

这里的 `from`，是属于 `String` 类型自身的一个方法，因此使用 `::` 运算符。接下来，在实例化 `h` 之后，我们能调用实例方法通过 `.` 运算符。例子如下：

```rust
println!("{} is {} letters long", h, h.len());
```

在这个例子中，`len()` 是一个实例方法 。有趣的是，`::` 操作符还有其他功能。`::` 也用于在导入带有 `use` 关键字的库时引用模块路径。举例来说，通过使用 `use` 关键字引用模块路径，我们可以导入 `PI` 标识符，如下所示：

```rust
use std::f64::consts::PI;

fn main() {
        println!("Pi = {}", PI);
}
```

这既是 `::` 的全部用法了吗？任然不是，本文第四点关于会继续聊到更多关于双冒号的用法。在那种情况下，它与另一个操作符合组合并形成一些新的东西。

**3) 感叹号 !**

在早期学习 Rust 的时候，我总是遇到 `!` ， 从 `println!` 开始， 接着是 `panic!` 以及 `vec!` 。尽管这些学习资料将 `println!` ，`panic!` 和 `vec!` 称之为宏，我也并不能理解，直到后来我才意识到所有以 `!` 结尾的标识符都是宏。这说明 `!` 是区分宏和普通函数所需的调用语法的一部分。如果您不熟悉 ”宏“， 它其实在编译时将静态生成的代码替换掉的一种调用，而不是像常规函数那样在运行时动态调用。

**4) 涡轮鱼（turbofish）运算符**

在 Rust 中，泛型是十分有趣和强大的概念。简言之，泛型允许您声明枚举或结构体的通用类型，然后编译器可以在编译时推断这些类型。他们看起来像这样：

```rust
struct MyStruct<T> {
    item: T,
}
```

在 `MyStruct` 的定义中，我们并没有规定具体的类型。只有一个泛型 `T` 。之后，在编译阶段，Rust 编译器会从 `MyStruct` 的声明中找出类型并填入。我的问题是，在某些情况下，我看到了看起来很奇怪的声明示例，它们看起来像这样：

```rust
let var = MyStruct::<i32> { item: 3 };
```

这让我想知道 `::<T>` 操作符是从哪里来的（这给第二点提到的 `::` 冒号运算符变得更加难以理解）。原来这被称为涡轮鱼运算符。当编译器不确定推断的类型，需要您作为程序员的帮助来告知类型时，可以使用它。

**5) `?` 运算符**

关于第五点和第六点要介绍的内容，是我认为不论放在哪一门编程语言里，都会增加其学习难度的点。在学习过程中，提早地将简写符号被引入学习中。我真心认为，在初学者的学习资源中，简写不应该高频的使用，至少同时要使用非简写符号，能不断提醒自己这是如何工作的。简写符号最好是当作，对代码熟练掌握之后的一种加强编码风格的小技巧。现在让我们看看 `?` 操作符。在某些情况下，会遇到这样的代码：

```rust
let x = function_call()?;
```

这段代码直接与 `Result` 枚举相关。我不打算谈太多细节，但学习 Rust 你要知道， `Result` 是 Rust 内置的枚举泛型，是一个允许程序员返回的可能失败的值。这是编程语言处理错误的方式。而 `?` 操作符相当于是对 `Result` 模式匹配的简写，等同于：

```rust
let x = match function_call() {
    Ok(x) => x,
    Err(e) => return Err(e),
}
```

在解构后，`x` 要么包含 `function_call` 返回值 `Result` 中的 `Ok` 的值，要么返回 `Err` 变量中的值并且从未分配 `x`。

**6) `if let` 和 `while let`**

`if let` 在《Rust 程序设计》第 6.3 节介绍过，我花了一段时间才消化。简单来说，这是一个更简洁的对 `Option` 枚举进行模式匹配的语法。与 `Result` 枚举的思想相似，Rust 不使用 `null` 而使用泛型的 `Option` 枚举来表示可以为空的值。通常，在解构一个选项时，我们会这样做：

```rust
match res {
        Some(x) => println!("value is {}", x),
        None ()=> (),
    }
```

而使用 `if let` 则可以写成下面这种方式：

```rust
if let Some(x) = res {
         println!("value is {}", x);
    }
```

可以这么理解，如果 `res` 等于（匹配） `Some(x)` ，那么执行 `println!`，否则，什么也不做。需要注意的是，当执行到 `if let` 时，如果 `res` 等于 `None` 我们什么也不做。另一方面，`while let` 遵循类似的方法，不同之处在于引入了一个条件，只要值与某个模式匹配，就需要循环。

**总结**

学习 Rust 并不是一件容易的事情，尽管我个人发现它是最令人满意和让我感到享受的。特别是当你试图理解在底层发生的事情时，你开始有很多这样的想法: “嗯，这很有意义!” 瞬间。有时我仍然觉得编码有点难以应对，没有以我预期的那样清晰。这可能是因为我总是试图在脑海中将我过去学过的其他语言联系起来。虽然我提到的 6 个关键时刻，可能是我学习旅程中最具转变性的时刻。你的经历是什么样的？你学习 Rust 的关键时刻是什么？